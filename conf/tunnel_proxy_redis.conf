    # TCP 代理日志格式定义
    log_format tcp_proxy '$remote_addr [$time_local] '
                         '$protocol $status $bytes_sent $bytes_received '
                         '$session_time "$upstream_addr" '
                         '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';
    # TCP 代理日志配置
    access_log /usr/local/openresty/nginx/logs/tcp-access.log tcp_proxy;
    open_log_file_cache off;

    # TCP 代理配置
    upstream real_server {
        server 0.0.0.0:1101; # 这里可以随便写，下面的代码块会覆盖这个地址

        balancer_by_lua_block {
            -- 初始化 balancer
            local balancer = require "ngx.balancer"
            local host = ""
            local port = 0

            host = ngx.ctx.proxy_host
            port = ngx.ctx.proxy_port
            -- 设置代理服务器地址
            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set current peer: ", err)
                return ngx.exit(ngx.ERROR)
            end
        }
    }

    server {
        preread_by_lua_block {
            local redis = require "resty.redis"
            local redis_instance = redis:new()

            -- 设置超时（毫秒） 5秒
            redis_instance:set_timeout(5000)

            -- 一些 redis 连接配置
            local rdb_host = "192.168.1.209"
            local rdb_port = 6379
            local rdb_pwd = ""
            local rdb_db = 1
            -- 存放代理服务器地址的 zset 表名称
            local zset_table_name = "tunnel_proxy_pool"

            -- 连接到 Redis
            local ok, err = redis_instance:connect(rdb_host, rdb_port)
            if not ok then
                ngx.log(ngx.ERR, "failed to connect to Redis: [", ok, "] err msg ==> " err)
                return redis_instance:close()
            end
            -- 选择数据库
            local ok, err = redis_instance:select(rdb_db)
            if not ok then
                ngx.log(ngx.ERR, "failed to select Redis DB: [", ok, "] err msg ==> " err)
                return redis_instance:close()
            end

            -- 设置密码
            if rdb_pwd and rdb_pwd ~= "" then
                local ok, err = redis_instance:auth(rdb_pwd)
                if not ok then
                    ngx.log(ngx.ERR, "failed to auth Redis: [", ok, "] err msg ==> " err)
                    return redis_instance:close()
                end
            end

            -- 先检查 zset 表中是否存在或者是否有数据
            local hosts_count, err = redis_instance:zcard(zset_table_name)
            if not hosts_count or hosts_count <= 0 then
                ngx.log(ngx.ERR, "no available proxy servers in Redis zset table: ", zset_table_name)
                return redis_instance:close()
            end
            -- 获取分数最低的前 1 个代理服务器地址
            local res, err = redis_instance:zrange(zset_table_name, 0, 0, "WITHSCORES")
            if not res or #res == 0 then
                ngx.log(ngx.ERR, "failed to get proxy server from Redis zset table: ", zset_table_name)
                return redis_instance:close()
            end
            -- 解析结果（假设之前存入 zset 的元素类似 127.0.0.1:8080、127.0.0.1:8181 分数为使用次数）
            local proxy_ip, proxy_port = res[1]:match("([^:]+):(%d+)")
            if not proxy_ip or not proxy_port then
                ngx.log(ngx.ERR, "failed to parse proxy server address: ", res[1])
                return redis_instance:close()
            end
            -- 获取了当前代理服务器地址后，给其分数加 1，表示当前已经使用过一次
            local ok, err = redis_instance:zincrby(zset_table_name, 1, res[1])
            if not ok then
                ngx.log(ngx.ERR, "failed to increment proxy server score in Redis zset table: ", zset_table_name)
                return redis_instance:close()
            end

            -- 将获取到的代理服务器地址存入 ngx.ctx 中，供 balancer_by_lua_block 使用
            ngx.ctx.proxy_host = proxy_ip
            ngx.ctx.proxy_port = tonumber(proxy_port)
            ngx.log(ngx.INFO, "using proxy server ==> ", proxy_ip, ":", proxy_port)
            -- 关闭 Redis 连接
            return redis_instance:close()

        }

        # 下面是对外暴露的端口
        listen 9527;
        proxy_pass real_server;
        proxy_connect_timeout 5s;
        proxy_timeout 15s;
    }