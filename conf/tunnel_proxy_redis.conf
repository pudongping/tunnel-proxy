# 自定义 TCP 日志格式定义
# 包含连接的 IP、时间、协议、状态、流量、会话时长、上游地址及流量等
log_format tcp_proxy '$remote_addr [$time_local] '
                     '$protocol $status $bytes_sent $bytes_received '
                     '$session_time "$upstream_addr" '
                     '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time"';
# 启用日志记录到指定文件，并使用自定义格式
access_log /usr/local/openresty/nginx/logs/tcp-access.log tcp_proxy;
open_log_file_cache off;

# TCP 代理配置
# upstream 块中定义一个占位 server
# 注意：0.0.0.0:1101 实际不会使用，真正地址会被 balancer_by_lua_block 动态覆盖
upstream real_server {
    server 0.0.0.0:1101;

    # 使用 balancer_by_lua_block 动态设置后端目标主机和端口
    balancer_by_lua_block {
        -- 检查 preread 阶段是否已经设置了 proxy_host 和 proxy_port
        -- 从 ngx.ctx 中获取代理服务器地址
        if not ngx.ctx.proxy_host or not ngx.ctx.proxy_port then
            ngx.log(ngx.ERR, "====>proxy_host or proxy_port is not set in ngx.ctx<====")
            return
        end

        -- 初始化 balancer
        local balancer = require "ngx.balancer"
        local host = ""
        local port = 0

        -- 从上下文中提取目标 IP 和端口
        host = ngx.ctx.proxy_host
        port = ngx.ctx.proxy_port
        -- 设置代理服务器地址
        local ok, err = balancer.set_current_peer(host, port)
        if not ok then
            ngx.log(ngx.ERR, "====>failed to set current peer: " .. tostring(err) .. "<====")
            return
        end
    }
}

# 定义 TCP server 模块（stream）监听端口和代理逻辑
server {
    # preread_by_lua_block 在客户端连接建立时就会触发，用于预处理逻辑
    preread_by_lua_block {
        -- https://github.com/openresty/lua-resty-redis
        local redis = require "resty.redis"
        local redis_instance = redis:new()

        -- 设置 Redis 操作超时时间（毫秒）
        redis_instance:set_timeout(5000)

        -- 一些 redis 连接配置
        local rdb_host = "192.168.1.208"
        local rdb_port = 6379
        local rdb_pwd = ""
        local rdb_db = 1
        -- 存放代理服务器地址的 zset 表名称
        local zset_table_name = "tunnel_proxy_pool"

        -- 连接到 Redis
        local ok, err = redis_instance:connect(rdb_host, rdb_port)
        if not ok then
            ngx.log(ngx.ERR, "====>failed to connect to Redis: [" .. tostring(ok) .. "] err msg ==> " .. tostring(err) .. "<====")
            return
        end

        -- 选择数据库
        local ok, err = redis_instance:select(rdb_db)
        if not ok then
            ngx.log(ngx.ERR, "====>failed to select Redis DB: [" .. tostring(ok) .. "] err msg ==> " .. tostring(err) .. "<====")
            return
        end

        -- 如果设置了密码，则进行认证
        if rdb_pwd and rdb_pwd ~= "" then
            local ok, err = redis_instance:auth(rdb_pwd)
            if not ok then
                ngx.log(ngx.ERR, "====>failed to auth Redis: [" .. tostring(ok) .. "] err msg ==> " .. tostring(err) .. "<====")
                return
            end
        end

        -- 先检查 zset 表是否存在或者是否有数据
        local hosts_count, err = redis_instance:zcard(zset_table_name)
        if not hosts_count or hosts_count <= 0 then
            ngx.log(ngx.ERR, "====>no available proxy servers in Redis zset table: " .. tostring(zset_table_name) .. " ==> " .. tostring(err) .. "<====")
            return
        end
        -- 获取分数最低的前 1 个代理服务器地址
        local res, err = redis_instance:zrange(zset_table_name, 0, 0, "WITHSCORES")
        if not res or #res == 0 then
            ngx.log(ngx.ERR, "====>failed to get proxy server from Redis zset table: " .. tostring(zset_table_name) .. "<====")
            return
        end
        -- 解析结果（假设之前存入 zset 的元素类似 127.0.0.1:8080、127.0.0.1:8181 分数为使用次数）
        local proxy_ip, proxy_port = res[1]:match("([^:]+):(%d+)")
        if not proxy_ip or not proxy_port then
            ngx.log(ngx.ERR, "====>failed to parse proxy server address ==> " .. tostring(res[1]) .. "<====")
            return
        end
        -- 获取了当前代理服务器地址后，给其分数加 1，表示当前已经使用过一次
        local ok, err = redis_instance:zincrby(zset_table_name, 1, res[1])
        if not ok then
            ngx.log(ngx.ERR, "====>failed to increment proxy server score in Redis zset table: " .. tostring(zset_table_name) .. " ==> " .. tostring(err) .. "<====")
            return
        end

        -- 将获取到的代理服务器地址存入 ngx.ctx 中，供 balancer_by_lua_block 使用
        ngx.ctx.proxy_host = proxy_ip
        ngx.ctx.proxy_port = tonumber(proxy_port)
        ngx.log(ngx.INFO, "====>using proxy server ==> " .. tostring(proxy_ip) .. ":" .. tostring(proxy_port) .. "<====")

        -- 释放 Redis 连接，否则连接池将保留不完整的连接状态
        ok, err = redis_instance:set_keepalive(10000, 100)
        if not ok then
            ngx.log(ngx.ERR, "====>failed to set Redis keepalive: " .. tostring(err) .. "<====")
        end
    }

    # 对外暴露的监听端口
    listen 0.0.0.0:9527;
    # 设置代理的目标 upstream 名称
    proxy_pass real_server;
    proxy_connect_timeout 5s;
    proxy_timeout 15s;
}